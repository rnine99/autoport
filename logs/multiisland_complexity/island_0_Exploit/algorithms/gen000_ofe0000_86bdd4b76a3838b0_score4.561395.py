
from utility_objective_functions import sinr_balancing_power_constraint
import numpy as np 
def select_ports(K, N_selected, N_Ports, Pt, n, H, noise):
    """   
   Select N_selected out of N_Ports ports to maximize the average objective value of n communications channels.

    Args:
        K: The number of users.
        N_selected: The number ports to be selected.  
        N_ports: Total number of ports available for each channel realization.        
        Pt: Total transmit power available.
        n: Total number of channel realizations.
        H: Numpy array of shape (n, N_Ports,K). It denotes n channel realizations.
        noise: Noise power, it is a NumPy scalar.

    Returns:
        port_sample: Numpy array of shape (n, N_selected), where n and N_selected are defined above. 
        For each row of it, all values should be integers from 0 to N_Ports-1 and cannot be repeated.
      

    For the n-th channel realization H(n, :,:), a valid port selection solution p must have the shape (1,N_selected)
    where N_selected is defined above and its elements are integers from 0 to N_Ports-1 and cannot be repeated. 
    The effective channel becomes h_n = H[n,p,:]. The objective value will be calculated using 
    the pre-defined function f_n=sinr_balancing_power_constraint(N_selected, K, h_n, Pt, noise).
    This function will maximize the average objective value of n channels. 
    """
    port_sample = np.zeros((n, N_selected), dtype=int)
    for i in range(n):
        selected = np.array([], dtype=int)
        remaining = np.arange(N_Ports)
        while len(selected) < N_selected:
            best_gain = -np.inf
            best_port = -1
            for cand in remaining:
                temp_selected = np.append(selected, cand)
                h_temp = H[i, temp_selected, :]
                val = sinr_balancing_power_constraint(len(temp_selected), K, h_temp, Pt, noise)
                if val > best_gain:
                    best_gain = val
                    best_port = cand
            selected = np.append(selected, best_port)
            remaining = remaining[remaining != best_port]
        h_current = H[i, selected, :]
        current_val = sinr_balancing_power_constraint(N_selected, K, h_current, Pt, noise)
        for _ in range(100):
            idx1, idx2 = np.random.choice(N_selected, size=2, replace=False)
            swap_cand = np.random.choice([p for p in range(N_Ports) if p not in selected])
            selected_temp = selected.copy()
            selected_temp[idx1] = swap_cand
            h_temp = H[i, selected_temp, :]
            val1 = sinr_balancing_power_constraint(N_selected, K, h_temp, Pt, noise)
            selected_temp2 = selected.copy()
            selected_temp2[idx2] = swap_cand
            h_temp2 = H[i, selected_temp2, :]
            val2 = sinr_balancing_power_constraint(N_selected, K, h_temp2, Pt, noise)
            if val1 > current_val and val1 >= val2:
                selected = selected_temp
                current_val = val1
            elif val2 > current_val:
                selected = selected_temp2
                current_val = val2
        improved = True
        while improved:
            improved = False
            for idx1 in range(N_selected):
                for idx2 in range(N_Ports):
                    if idx2 in selected:
                        continue
                    selected_temp = selected.copy()
                    selected_temp[idx1] = idx2
                    h_temp = H[i, selected_temp, :]
                    val = sinr_balancing_power_constraint(N_selected, K, h_temp, Pt, noise)
                    if val > current_val:
                        selected = selected_temp
                        current_val = val
                        improved = True
                        break
                if improved:
                    break
        port_sample[i] = selected
    return port_sample

