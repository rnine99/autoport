
from utility_objective_functions import sinr_balancing_power_constraint
import numpy as np

def select_ports(K, N_selected, N_Ports, Pt, n, H, noise):
    """
    Select N_selected out of N_Ports ports to maximize the average objective value.

    Args:
        K: The number of users.
        N_selected: The number ports to be selected.
        N_Ports: Total number of ports available.
        Pt: Total transmit power available.
        n: Total number of channel realizations.
        H: Numpy array of shape (n, N_Ports, K).
        noise: Noise power.

    Returns:
        port_sample: Numpy array of shape (n, N_selected).
                     Values must be integers from 0 to N_Ports-1, no repeats per row.

    # --- ⬇️ REFERENCE EXAMPLE (DO NOT COPY, JUST REFERENCE) ⬇️ ---
    # Example: Random Selection
    # port_sample = np.zeros((n, N_selected), dtype=int)
    # for j in range(n):
    #     # Randomly choose N_selected ports
    #     p = np.random.choice(N_Ports, N_selected, replace=False)
    #     port_sample[j, :] = p
    # return port_sample
    # -----------------------------------------------------------
    """
    sinr_mean = np.mean(H, axis=0)
    sinr_mean = sinr_mean.reshape(-1, 1)

    # Define the heuristic function to choose the N_selected ports
    def heuristic_function(sinr_mean, N_selected, N_Ports):
        max_sinr = np.max(sinr_mean)
        min_sinr = np.min(sinr_mean)
        q = (max_sinr - min_sinr) / N_selected
        return (sinr_mean - min_sinr) / q

    # Initialize port_sample with zeros
    port_sample = np.zeros((n, N_selected), dtype=int)

    # Select the top N_selected ports with the highest average SINR using the heuristic function
    for j in range(n):
        port_indices = np.argsort(heuristic_function(sinr_mean[j], N_selected, N_Ports))[::-1][:N_selected]
        port_sample[j, :] = port_indices

    return port_sample

