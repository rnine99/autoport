
from utility_objective_functions import sinr_balancing_power_constraint
import numpy as np 
def select_ports(K, N_selected, N_Ports, Pt, n, H, noise):
    """   
   Select N_selected out of N_Ports ports to maximize the average objective value of n communications channels.

    Args:
        K: The number of users.
        N_selected: The number ports to be selected.  
        N_ports: Total number of ports available for each channel realization.        
        Pt: Total transmit power available.
        n: Total number of channel realizations.
        H: Numpy array of shape (n, N_Ports,K). It denotes n channel realizations.
        noise: Noise power, it is a NumPy scalar.

    Returns:
        port_sample: Numpy array of shape (n, N_selected), where n and N_selected are defined above. 
        For each row of it, all values should be integers from 0 to N_Ports-1 and cannot be repeated.
      

    For the n-th channel realization H(n, :,:), a valid port selection solution p must have the shape (1,N_selected)
    where N_selected is defined above and its elements are integers from 0 to N_Ports-1 and cannot be repeated. 
    The effective channel becomes h_n = H[n,p,:]. The objective value will be calculated using 
    the pre-defined function f_n=sinr_balancing_power_constraint(N_selected, K, h_n, Pt, noise).
    This function will maximize the average objective value of n channels. 
    """
    port_sample = np.zeros((n, N_selected), dtype=int)
    
    for i in range(n):
        H_i = H[i]  # shape (N_Ports, K)
        gains = np.zeros(N_Ports)
        for port in range(N_Ports):
            h_single = H_i[port:port+1, :]
            if np.linalg.matrix_rank(h_single) > 0:
                f_val = sinr_balancing_power_constraint(1, K, h_single, Pt, noise)
                gains[port] = f_val
            else:
                gains[port] = -np.inf
        
        # Compute correlation penalty
        penalty = np.zeros(N_Ports)
        sorted_idx = np.argsort(gains)[::-1]
        for idx, port in enumerate(sorted_idx):
            if gains[port] == -np.inf:
                continue
            higher_ports = sorted_idx[:idx]
            if len(higher_ports) > 0:
                corr_sum = 0.0
                for hp in higher_ports:
                    if gains[hp] == -np.inf:
                        continue
                    corr = np.abs(np.corrcoef(H_i[port], H_i[hp])[0,1])
                    if np.isnan(corr):
                        corr = 0.0
                    corr_sum += corr
                penalty[port] = corr_sum / len(higher_ports)
        
        # Adjust gains with penalty
        adjusted_gains = gains - 0.5 * penalty * np.max(gains[gains != -np.inf])
        top_ports = np.argsort(adjusted_gains)[-N_selected:]
        port_sample[i] = top_ports
    
    return port_sample

