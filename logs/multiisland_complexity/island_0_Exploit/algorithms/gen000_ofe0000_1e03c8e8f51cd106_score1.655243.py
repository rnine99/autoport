
from utility_objective_functions import sinr_balancing_power_constraint
import numpy as np 
def select_ports(K, N_selected, N_Ports, Pt, n, H, noise):
    """   
   Select N_selected out of N_Ports ports to maximize the average objective value of n communications channels.

    Args:
        K: The number of users.
        N_selected: The number ports to be selected.  
        N_ports: Total number of ports available for each channel realization.        
        Pt: Total transmit power available.
        n: Total number of channel realizations.
        H: Numpy array of shape (n, N_Ports,K). It denotes n channel realizations.
        noise: Noise power, it is a NumPy scalar.

    Returns:
        port_sample: Numpy array of shape (n, N_selected), where n and N_selected are defined above. 
        For each row of it, all values should be integers from 0 to N_Ports-1 and cannot be repeated.
      

    For the n-th channel realization H(n, :,:), a valid port selection solution p must have the shape (1,N_selected)
    where N_selected is defined above and its elements are integers from 0 to N_Ports-1 and cannot be repeated. 
    The effective channel becomes h_n = H[n,p,:]. The objective value will be calculated using 
    the pre-defined function f_n=sinr_balancing_power_constraint(N_selected, K, h_n, Pt, noise).
    This function will maximize the average objective value of n channels. 
    """
    population_size = 50
    generations = 20
    mutation_rate = 0.1
    elite_size = max(2, population_size // 10)
    
    population = []
    for _ in range(population_size):
        ind = np.random.choice(N_Ports, size=N_selected, replace=False)
        population.append(np.sort(ind))
    
    for gen in range(generations):
        fitness = np.zeros(population_size)
        for idx, ind in enumerate(population):
            total_val = 0.0
            for i in range(n):
                h_n = H[i, ind, :]
                total_val += sinr_balancing_power_constraint(N_selected, K, h_n, Pt, noise)
            fitness[idx] = total_val / n
        
        elite_indices = np.argsort(fitness)[-elite_size:]
        new_population = [population[i] for i in elite_indices]
        
        while len(new_population) < population_size:
            if np.random.rand() < 0.7 and len(elite_indices) >= 2:
                p1, p2 = np.random.choice(elite_indices, size=2, replace=False)
                parent1, parent2 = population[p1], population[p2]
                mask = np.random.rand(N_selected) < 0.5
                child = np.zeros(N_selected, dtype=int)
                child[mask] = parent1[mask]
                remaining = [g for g in parent2 if g not in child]
                fill_pos = np.where(~mask)[0]
                child[fill_pos[:len(remaining)]] = remaining[:len(fill_pos)]
                if len(remaining) < len(fill_pos):
                    unused = [g for g in range(N_Ports) if g not in child]
                    fill_pos = fill_pos[len(remaining):]
                    child[fill_pos] = np.random.choice(unused, size=len(fill_pos), replace=False)
            else:
                child = np.random.choice(N_Ports, size=N_selected, replace=False)
            
            if np.random.rand() < mutation_rate:
                swap_idx = np.random.randint(N_selected)
                unused = [g for g in range(N_Ports) if g not in child]
                if unused:
                    child[swap_idx] = np.random.choice(unused)
            
            new_population.append(np.sort(child))
        
        population = new_population
    
    port_sample = np.zeros((n, N_selected), dtype=int)
    for i in range(n):
        best_subset = None
        best_value = -np.inf
        for ind in population[:elite_size]:
            h_n = H[i, ind, :]
            f_val = sinr_balancing_power_constraint(N_selected, K, h_n, Pt, noise)
            if f_val > best_value:
                best_value = f_val
                best_subset = ind
        port_sample[i] = best_subset
    
    return port_sample

