
from utility_objective_functions import sinr_balancing_power_constraint
import numpy as np

def select_ports(K, N_selected, N_Ports, Pt, n, H, noise):
    """
    Select N_selected ports for each of n channel realizations to maximize SINR.

    Args:
        K, N_selected, N_Ports, Pt, n: Scalars (as defined in problem).
        H: Shape (n, N_Ports, K). âš ï¸ COMPLEX (complex128). Contains Real+Imag.
        noise: Scalar noise power.

    Returns:
        port_sample: Shape (n, N_selected), dtype=int. Indices 0..N_Ports-1.

    ==================================================================================
    ðŸ§  REFERENCE STRATEGIES (BASELINES)
    ==================================================================================
    
    # [Strategy 1] Simple Energy-Based (Fast)
    # Logic: Pick ports with the strongest channel magnitude |H|. Ignores interference.
    # ------------------------------------------------------------------
    # for j in range(n):
    #     channel_energy = np.sum(np.abs(H[j])**2, axis=1) # Sum energy across users
    #     port_sample[j, :] = np.argsort(channel_energy)[-N_selected:]
    
    # [Strategy 2] Iterative Greedy (High Performance)
    # Logic: Select ports one by one. Pick the next port that maximizes SINR 
    #        when combined with already selected ports.
    # ------------------------------------------------------------------
    # for j in range(n):
    #     selected = []
    #     for step in range(N_selected):
    #         best_port = -1
    #         best_score = -1.0
    #         # Try adding each remaining port
    #         for candidate in range(N_Ports):
    #             if candidate not in selected:
    #                 current_set = selected + [candidate]
    #                 # âš ï¸ This function call is hypothetical, adjust to your actual utility function
    #                 # score = calc_sinr(H[j], current_set) 
    #                 # if score > best_score: ...
    #         selected.append(best_port)
    #     port_sample[j, :] = selected

    ==================================================================================
    ðŸš€ YOUR TASK: IMPLEMENT A SUPERIOR ALGORITHM
    ==================================================================================
    """
    port_sample = np.zeros((n, N_selected), dtype=int)
    for j in range(n):
        selected = []
        for step in range(N_selected):
            best_port = -1
            best_score = -1.0
            for candidate in range(N_Ports):
                if candidate not in selected:
                    current_set = selected + [candidate]
                    # âš ï¸ This function call is hypothetical, adjust to your actual utility function
                    # score = calc_sinr(H[j], current_set) 
                    # if score > best_score: ...
            selected.append(best_port)
        port_sample[j, :] = selected

    return port_sample

