
from utility_objective_functions import sinr_balancing_power_constraint
import numpy as np 
def select_ports(K, N_selected, N_Ports, Pt, n, H, noise):
    """   
   Select N_selected out of N_Ports ports to maximize the average objective value of n communications channels.

    Args:
        K: The number of users.
        N_selected: The number ports to be selected.  
        N_ports: Total number of ports available for each channel realization.        
        Pt: Total transmit power available.
        n: Total number of channel realizations.
        H: Numpy array of shape (n, N_Ports,K). It denotes n channel realizations.
        noise: Noise power, it is a NumPy scalar.

    Returns:
        port_sample: Numpy array of shape (n, N_selected), where n and N_selected are defined above. 
        For each row of it, all values should be integers from 0 to N_Ports-1 and cannot be repeated.
      

    For the n-th channel realization H(n, :,:), a valid port selection solution p must have the shape (1,N_selected)
    where N_selected is defined above and its elements are integers from 0 to N_Ports-1 and cannot be repeated. 
    The effective channel becomes h_n = H[n,p,:]. The objective value will be calculated using 
    the pre-defined function f_n=sinr_balancing_power_constraint(N_selected, K, h_n, Pt, noise).
    This function will maximize the average objective value of n channels. 
    """
    port_sample = np.zeros((n, N_selected), dtype=int)
    for i in range(n):
        gains = np.sum(np.abs(H[i]), axis=1)
        ranked = np.argsort(gains)[::-1]
        selected = []
        unselected = list(ranked)
        while len(selected) < N_selected:
            best_obj = -np.inf
            best_port = -1
            for port in unselected:
                cand = selected + [port]
                h_cand = H[i, cand, :]
                cand_obj = sinr_balancing_power_constraint(len(cand), K, h_cand, Pt, noise)
                if cand_obj > best_obj:
                    best_obj = cand_obj
                    best_port = port
            selected.append(best_port)
            unselected.remove(best_port)
            if len(selected) > 1:
                worst_obj = np.inf
                worst_idx = -1
                for idx in range(len(selected)):
                    temp = selected.copy()
                    temp.pop(idx)
                    h_temp = H[i, temp, :]
                    temp_obj = sinr_balancing_power_constraint(len(temp), K, h_temp, Pt, noise)
                    if temp_obj < worst_obj:
                        worst_obj = temp_obj
                        worst_idx = idx
                if worst_obj >= best_obj:
                    selected.pop(worst_idx)
                    unselected.append(selected.pop() if worst_idx == len(selected) else selected.pop(worst_idx))
        improved = True
        while improved:
            improved = False
            cur_h = H[i, selected, :]
            cur_obj = sinr_balancing_power_constraint(N_selected, K, cur_h, Pt, noise)
            for s_idx in range(N_selected):
                for u_idx in range(len(unselected)):
                    cand = selected.copy()
                    cand[s_idx] = unselected[u_idx]
                    h_cand = H[i, cand, :]
                    cand_obj = sinr_balancing_power_constraint(N_selected, K, h_cand, Pt, noise)
                    if cand_obj > cur_obj:
                        selected = cand
                        unselected[u_idx] = selected[s_idx]
                        improved = True
                        break
                if improved:
                    break
        port_sample[i] = selected
    return port_sample

