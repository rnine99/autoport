
from utility_objective_functions import sinr_balancing_power_constraint
import numpy as np

def select_ports(K, N_selected, N_Ports, Pt, n, H, noise):
    """
    Select N_selected out of N_Ports ports to maximize the average objective value.

    Args:
        K: The number of users.
        N_selected: The number ports to be selected.
        N_Ports: Total number of ports available.
        Pt: Total transmit power available.
        n: Total number of channel realizations.
        H: Numpy array of shape (n, N_Ports, K).
        noise: Noise power.

    Returns:
        port_sample: Numpy array of shape (n, N_selected).
                     Values must be integers from 0 to N_Ports-1, no repeats per row.

    # --- ⬇️ REFERENCE EXAMPLE (DO NOT COPY, JUST REFERENCE) ⬇️ ---
    # Example: Random Selection
    # port_sample = np.zeros((n, N_selected), dtype=int)
    # for j in range(n):
    #     # Randomly choose N_selected ports
    #     p = np.random.choice(N_Ports, N_selected, replace=False)
    #     port_sample[j, :] = p
    # return port_sample
    # -----------------------------------------------------------
    """
    metric = np.mean(H, axis=0)  # For example, compute the mean of the channel gains
    metric = metric.reshape(-1, 1)

    # Initialize port_sample with zeros
    port_sample = np.zeros((n, N_selected), dtype=int)

    # Select the top N_selected ports with the highest average metric
    for j in range(n):
        top_ports = np.argsort(metric[j])[::-1][:N_selected]
        port_sample[j, :] = top_ports

    return port_sample

