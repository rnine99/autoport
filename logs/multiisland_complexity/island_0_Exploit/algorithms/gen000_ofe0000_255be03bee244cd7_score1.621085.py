
from utility_objective_functions import sinr_balancing_power_constraint
import numpy as np 
def select_ports(K, N_selected, N_Ports, Pt, n, H, noise):
    """   
   Select N_selected out of N_Ports ports to maximize the average objective value of n communications channels.

    Args:
        K: The number of users.
        N_selected: The number ports to be selected.  
        N_ports: Total number of ports available for each channel realization.        
        Pt: Total transmit power available.
        n: Total number of channel realizations.
        H: Numpy array of shape (n, N_Ports,K). It denotes n channel realizations.
        noise: Noise power, it is a NumPy scalar.

    Returns:
        port_sample: Numpy array of shape (n, N_selected), where n and N_selected are defined above. 
        For each row of it, all values should be integers from 0 to N_Ports-1 and cannot be repeated.
      

    For the n-th channel realization H(n, :,:), a valid port selection solution p must have the shape (1,N_selected)
    where N_selected is defined above and its elements are integers from 0 to N_Ports-1 and cannot be repeated. 
    The effective channel becomes h_n = H[n,p,:]. The objective value will be calculated using 
    the pre-defined function f_n=sinr_balancing_power_constraint(N_selected, K, h_n, Pt, noise).
    This function will maximize the average objective value of n channels. 
    """
    population_size = 20
    generations = 30
    mutation_rate = 0.1
    
    port_sample = np.zeros((n, N_selected), dtype=int)
    
    for i in range(n):
        population = []
        for _ in range(population_size):
            ind = np.random.choice(N_Ports, size=N_selected, replace=False)
            population.append(ind)
        
        for gen in range(generations):
            fitness = []
            for ind in population:
                obj = sinr_balancing_power_constraint(N_selected, K, H[i, ind, :], Pt, noise)
                fitness.append(obj)
            
            fitness = np.array(fitness)
            sorted_idx = np.argsort(fitness)[::-1]
            elite = population[sorted_idx[0]]
            
            new_population = [elite]
            while len(new_population) < population_size:
                if np.random.rand() < 0.7 and len(new_population) < population_size - 1:
                    p1_idx = np.random.choice(sorted_idx[:population_size//2])
                    p2_idx = np.random.choice(sorted_idx[:population_size//2])
                    p1, p2 = population[p1_idx], population[p2_idx]
                    
                    split = np.random.randint(1, N_selected)
                    child1 = np.concatenate([p1[:split], p2[split:]])
                    child2 = np.concatenate([p2[:split], p1[split:]])
                    
                    for child in [child1, child2]:
                        child = np.unique(child)
                        while len(child) < N_selected:
                            new_port = np.random.choice([p for p in range(N_Ports) if p not in child])
                            child = np.append(child, new_port)
                        new_population.append(child[:N_selected])
                else:
                    parent_idx = np.random.choice(sorted_idx[:population_size//2])
                    child = population[parent_idx].copy()
                    
                    if np.random.rand() < mutation_rate:
                        swap_in = np.random.choice([p for p in range(N_Ports) if p not in child])
                        swap_out_idx = np.random.randint(N_selected)
                        child[swap_out_idx] = swap_in
                    new_population.append(child)
            
            population = new_population
        
        best_idx = 0
        best_value = -np.inf
        for idx, ind in enumerate(population):
            obj = sinr_balancing_power_constraint(N_selected, K, H[i, ind, :], Pt, noise)
            if obj > best_value:
                best_value = obj
                best_idx = idx
        
        port_sample[i] = np.sort(population[best_idx])
    
    return port_sample

