
from utility_objective_functions import sinr_balancing_power_constraint
import numpy as np 
def select_ports(K, N_selected, N_Ports, Pt, n, H, noise):
    """   
   Select N_selected out of N_Ports ports to maximize the average objective value of n communications channels.

    Args:
        K: The number of users.
        N_selected: The number ports to be selected.  
        N_ports: Total number of ports available for each channel realization.        
        Pt: Total transmit power available.
        n: Total number of channel realizations.
        H: Numpy array of shape (n, N_Ports,K). It denotes n channel realizations.
        noise: Noise power, it is a NumPy scalar.

    Returns:
        port_sample: Numpy array of shape (n, N_selected), where n and N_selected are defined above. 
        For each row of it, all values should be integers from 0 to N_Ports-1 and cannot be repeated.
      

    For the n-th channel realization H(n, :,:), a valid port selection solution p must have the shape (1,N_selected)
    where N_selected is defined above and its elements are integers from 0 to N_Ports-1 and cannot be repeated. 
    The effective channel becomes h_n = H[n,p,:]. The objective value will be calculated using 
    the pre-defined function f_n=sinr_balancing_power_constraint(N_selected, K, h_n, Pt, noise).
    This function will maximize the average objective value of n channels. 
    """
    port_sample = np.zeros((n, N_selected), dtype=int)
    
    def evaluate_fitness(subset, h_realization):
        h_sub = h_realization[subset, :]
        return sinr_balancing_power_constraint(N_selected, K, h_sub, Pt, noise)
    
    for i in range(n):
        H_i = H[i]
        pop_size = 20
        generations = 10
        population = []
        for _ in range(pop_size):
            ind = np.random.choice(N_Ports, N_selected, replace=False)
            population.append(ind)
        
        for gen in range(generations):
            fitness = np.array([evaluate_fitness(ind, H_i) for ind in population])
            sorted_idx = np.argsort(fitness)[::-1]
            elite = population[sorted_idx[0]]
            new_pop = [elite]
            while len(new_pop) < pop_size:
                p1, p2 = np.random.choice(sorted_idx[:pop_size//2], 2, replace=False)
                parent1, parent2 = population[p1], population[p2]
                common = np.intersect1d(parent1, parent2)
                remaining = np.setdiff1d(np.union1d(parent1, parent2), common)
                needed = N_selected - len(common)
                if needed > 0 and len(remaining) >= needed:
                    child = np.concatenate([common, np.random.choice(remaining, needed, replace=False)])
                else:
                    child = np.random.choice(N_Ports, N_selected, replace=False)
                if np.random.rand() < 0.2:
                    mutate_gene = np.random.randint(0, N_selected)
                    available = np.setdiff1d(np.arange(N_Ports), child)
                    if len(available) > 0:
                        child[mutate_gene] = np.random.choice(available)
                new_pop.append(np.sort(child))
            population = new_pop
        
        best_ind = None
        best_fit = -np.inf
        for ind in population:
            fit = evaluate_fitness(ind, H_i)
            if fit > best_fit:
                best_fit = fit
                best_ind = ind
        port_sample[i] = best_ind
    
    return port_sample

