
from utility_objective_functions import sinr_balancing_power_constraint
import numpy as np 
def select_ports(K, N_selected, N_Ports, Pt, n, H, noise):
    """   
   Select N_selected out of N_Ports ports to maximize the average objective value of n communications channels.

    Args:
        K: The number of users.
        N_selected: The number ports to be selected.  
        N_ports: Total number of ports available for each channel realization.        
        Pt: Total transmit power available.
        n: Total number of channel realizations.
        H: Numpy array of shape (n, N_Ports,K). It denotes n channel realizations.
        noise: Noise power, it is a NumPy scalar.

    Returns:
        port_sample: Numpy array of shape (n, N_selected), where n and N_selected are defined above. 
        For each row of it, all values should be integers from 0 to N_Ports-1 and cannot be repeated.
      

    For the n-th channel realization H(n, :,:), a valid port selection solution p must have the shape (1,N_selected)
    where N_selected is defined above and its elements are integers from 0 to N_Ports-1 and cannot be repeated. 
    The effective channel becomes h_n = H[n,p,:]. The objective value will be calculated using 
    the pre-defined function f_n=sinr_balancing_power_constraint(N_selected, K, h_n, Pt, noise).
    This function will maximize the average objective value of n channels. 
    """
    port_sample = np.zeros((n, N_selected), dtype=int)
    # Step 1: Greedy selection of a common initial set based on average objective
    available = list(range(N_Ports))
    common_selected = []
    for _ in range(N_selected):
        best_port = -1
        best_avg_value = -np.inf
        for port in available:
            candidate = common_selected + [port]
            avg_val = 0.0
            for i in range(n):
                h_n = H[i, candidate, :]
                f_val = sinr_balancing_power_constraint(len(candidate), K, h_n, Pt, noise)
                avg_val += f_val
            avg_val /= n
            if avg_val > best_avg_value:
                best_avg_value = avg_val
                best_port = port
        common_selected.append(best_port)
        available.remove(best_port)
    
    # Step 2: Local refinement per realization via one-port swaps
    for i in range(n):
        current = common_selected.copy()
        improved = True
        while improved:
            improved = False
            best_swap = (None, None, -np.inf)
            # Try swapping each selected port with each unselected port
            selected_set = set(current)
            unselected = [p for p in range(N_Ports) if p not in selected_set]
            for sel_idx, sel_port in enumerate(current):
                for unsel_port in unselected:
                    candidate = current.copy()
                    candidate[sel_idx] = unsel_port
                    h_n = H[i, candidate, :]
                    f_val = sinr_balancing_power_constraint(N_selected, K, h_n, Pt, noise)
                    if f_val > best_swap[2]:
                        best_swap = (sel_idx, unsel_port, f_val)
            # Evaluate current configuration
            h_current = H[i, current, :]
            current_val = sinr_balancing_power_constraint(N_selected, K, h_current, Pt, noise)
            if best_swap[2] > current_val:
                current[best_swap[0]] = best_swap[1]
                improved = True
        port_sample[i] = current
    return port_sample

